package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"errors"
	"fmt"
	"leaderboard_service/graph/model"
	"leaderboard_service/kafka"
	"log"
	"strings"
	"time"

	redis "github.com/go-redis/redis/v8"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, userName string, score int32) (*model.Leaderboard, error) {
	var user model.Leaderboard
	err := r.DB.QueryRow("INSERT INTO leaderboard (user_name, rank, score) VALUES ($1, $2, $3) RETURNING user_id, user_name, rank, score;", userName, 0, score).Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score)
	if err != nil {
		return nil, err
	}
	// Update the ranks after adding the new user
	// updateRanks(r.DB) // This is no longer needed and is a performance bottleneck

	// Also update Redis to keep it in sync
	r.RDB.ZAdd(context.Background(), kafka.RedisLeaderboardKey, &redis.Z{
		Score:  float64(score),
		Member: user.UserID,
	})
	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, userName *string, score *int32) (*model.Leaderboard, error) {
	if userName != nil {
		_, err := r.DB.Exec("UPDATE leaderboard SET user_name = $1 WHERE user_id = $2;", *userName, userID)
		if err != nil {
			return nil, err
		}
	}
	if score != nil {
		_, err := r.DB.Exec("UPDATE leaderboard SET score = $1 WHERE user_id = $2;", *score, userID)
		if err != nil {
			return nil, err
		}
	}
	// Update the ranks after modifying the user
	// updateRanks(r.DB) // This is no longer needed

	// Also update Redis to keep it in sync
	if score != nil {
		r.RDB.ZAdd(context.Background(), kafka.RedisLeaderboardKey, &redis.Z{Score: float64(*score), Member: userID})
	}

	var user model.Leaderboard
	err := r.DB.QueryRow("SELECT user_id, user_name, rank, score FROM leaderboard WHERE user_id = $1;", userID).Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (bool, error) {
	_, err := r.DB.Exec("DELETE FROM leaderboard WHERE user_id = $1;", userID)
	if err != nil {
		return false, err
	}
	// updateRanks(r.DB) // This is no longer needed

	// Also remove from Redis
	r.RDB.ZRem(context.Background(), kafka.RedisLeaderboardKey, userID)
	return true, nil
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context, limit *int32) (*model.LeaderboardResponse, error) {
	startTime := time.Now()
	if r == nil {
		return nil, errors.New("queryResolver is nil")
	}

	if r.RDB == nil || r.DB == nil {
		return nil, errors.New("redis or database is not initialized")
	}

	// Get sorted leaderboard from Redis
	// ZREVRANGE to get scores in descending order (highest first)
	// WITHSCORES to get both member (user_id) and their score
	// Use limit if provided, otherwise fetch all entries
	end := int64(-1) // Default to all entries
	if limit != nil {
		end = int64(*limit) - 1 // -1 because Redis range is inclusive
	}
	redisResult, err := r.RDB.ZRevRangeWithScores(ctx, kafka.RedisLeaderboardKey, 0, end).Result()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch from Redis: %w", err)
	}

	if len(redisResult) == 0 {
		queryTime := time.Since(startTime).Seconds() * 1000
		return &model.LeaderboardResponse{
			Data: []*model.Leaderboard{},
			Metrics: &model.QueryMetrics{
				QueryTime:   queryTime,
				RecordCount: 0,
				DataSource:  "Redis",
			},
		}, nil
	}

	// Create a map to store user IDs and their scores
	userScores := make(map[string]float64)
	var userIDs []string

	// Extract user IDs and scores from Redis result
	for _, z := range redisResult {
		userID := fmt.Sprint(z.Member)
		userIDs = append(userIDs, userID)
		userScores[userID] = z.Score
	}

	// Fetch user names from PostgreSQL for all users in the leaderboard
	// Using string_to_array to convert list of UUIDs to a PostgreSQL array
	query := "SELECT user_id, user_name FROM leaderboard WHERE user_id = ANY(string_to_array($1, ',')::uuid[])"
	userIDsList := strings.Join(userIDs, ",")
	rows, err := r.DB.Query(query, userIDsList)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user names: %w", err)
	}
	defer rows.Close()

	// Create a map of user IDs to their names
	userNames := make(map[string]string)
	for rows.Next() {
		var userID, userName string
		if err := rows.Scan(&userID, &userName); err != nil {
			return nil, fmt.Errorf("failed to scan user data: %w", err)
		}
		userNames[userID] = userName
	}

	// Build the final leaderboard
	var leaderboard []*model.Leaderboard
	for rank, z := range redisResult {
		userID := fmt.Sprint(z.Member)
		user := &model.Leaderboard{
			UserID:   userID,
			UserName: userNames[userID],
			Score:    int32(z.Score),
			Rank:     int32(rank + 1), // rank is 0-based, add 1 for human-readable ranks
		}
		leaderboard = append(leaderboard, user)
	}

	queryTime := time.Since(startTime).Seconds() * 1000 // Convert to milliseconds
	log.Printf("Redis Leaderboard rows: %d, Query time: %.2fms", len(leaderboard), queryTime)

	return &model.LeaderboardResponse{
		Data: leaderboard,
		Metrics: &model.QueryMetrics{
			QueryTime:   queryTime,
			RecordCount: int32(len(leaderboard)),
			DataSource:  "Redis",
		},
	}, nil
}

// LeaderboardSQL is the resolver for the leaderboardSQL field.
func (r *queryResolver) LeaderboardSQL(ctx context.Context, limit *int32) (*model.LeaderboardResponse, error) {
	startTime := time.Now()
	if r == nil || r.DB == nil {
		return nil, errors.New("database is not initialized")
	}

	// Build the query with window functions to calculate ranks
	query := `
		WITH RankedScores AS (
			SELECT 
				user_id,
				user_name,
				score,
				RANK() OVER (ORDER BY score DESC) as rank
			FROM leaderboard
		)
		SELECT user_id, user_name, rank, score 
		FROM RankedScores
	`

	// Add limit if provided
	if limit != nil {
		query += fmt.Sprintf(" LIMIT %d", *limit)
	}

	// Execute the query
	rows, err := r.DB.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch from PostgreSQL: %w", err)
	}
	defer rows.Close()

	// Build the leaderboard
	var leaderboard []*model.Leaderboard
	for rows.Next() {
		user := &model.Leaderboard{}
		if err := rows.Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score); err != nil {
			return nil, fmt.Errorf("failed to scan user data: %w", err)
		}
		leaderboard = append(leaderboard, user)
	}

	queryTime := time.Since(startTime).Seconds() * 1000 // Convert to milliseconds
	log.Printf("SQL Leaderboard rows: %d, Query time: %.2fms", len(leaderboard), queryTime)

	return &model.LeaderboardResponse{
		Data: leaderboard,
		Metrics: &model.QueryMetrics{
			QueryTime:   queryTime,
			RecordCount: int32(len(leaderboard)),
			DataSource:  "PostgreSQL",
		},
	}, nil
}

// UserByID is the resolver for the userById field.
func (r *queryResolver) UserByID(ctx context.Context, userID string) (*model.Leaderboard, error) {
	var user model.Leaderboard
	err := r.DB.QueryRow("SELECT user_id, user_name, rank, score FROM leaderboard WHERE user_id = $1;", userID).Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
