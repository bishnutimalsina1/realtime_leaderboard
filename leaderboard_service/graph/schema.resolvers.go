package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"errors"
	"fmt"
	"leaderboard_service/graph/model"
	"leaderboard_service/kafka"
	"log"

	"github.com/go-redis/redis/v8"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, userName string, score int32) (*model.Leaderboard, error) {
	var user model.Leaderboard
	err := r.DB.QueryRow("INSERT INTO leaderboard (user_name, rank, score) VALUES ($1, $2, $3) RETURNING user_id, user_name, rank, score;", userName, 0, score).Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score)
	if err != nil {
		return nil, err
	}
	// Update the ranks after adding the new user
	// updateRanks(r.DB) // This is no longer needed and is a performance bottleneck

	// Also update Redis to keep it in sync
	r.RDB.ZAdd(context.Background(), kafka.RedisLeaderboardKey, &redis.Z{
		Score:  float64(score),
		Member: user.UserID,
	})
	return &user, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, userName *string, score *int32) (*model.Leaderboard, error) {
	if userName != nil {
		_, err := r.DB.Exec("UPDATE leaderboard SET user_name = $1 WHERE user_id = $2;", *userName, userID)
		if err != nil {
			return nil, err
		}
	}
	if score != nil {
		_, err := r.DB.Exec("UPDATE leaderboard SET score = $1 WHERE user_id = $2;", *score, userID)
		if err != nil {
			return nil, err
		}
	}
	// Update the ranks after modifying the user
	// updateRanks(r.DB) // This is no longer needed

	// Also update Redis to keep it in sync
	if score != nil {
		r.RDB.ZAdd(context.Background(), kafka.RedisLeaderboardKey, &redis.Z{Score: float64(*score), Member: userID})
	}

	var user model.Leaderboard
	err := r.DB.QueryRow("SELECT user_id, user_name, rank, score FROM leaderboard WHERE user_id = $1;", userID).Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (bool, error) {
	_, err := r.DB.Exec("DELETE FROM leaderboard WHERE user_id = $1;", userID)
	if err != nil {
		return false, err
	}
	// updateRanks(r.DB) // This is no longer needed

	// Also remove from Redis
	r.RDB.ZRem(context.Background(), kafka.RedisLeaderboardKey, userID)
	return true, nil
}

// Leaderboard is the resolver for the leaderboard field.
func (r *queryResolver) Leaderboard(ctx context.Context) ([]*model.Leaderboard, error) {
	if r == nil {
		return nil, errors.New("queryResolver is nil")
	}

	if r.RDB == nil || r.DB == nil {
		return nil, errors.New("redis or database is not initialized")
	}

	// Get sorted leaderboard from Redis
	// ZREVRANGE to get scores in descending order (highest first)
	// WITHSCORES to get both member (user_id) and their score
	redisResult, err := r.RDB.ZRevRangeWithScores(ctx, kafka.RedisLeaderboardKey, 0, -1).Result()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch from Redis: %w", err)
	}

	if len(redisResult) == 0 {
		return []*model.Leaderboard{}, nil
	}

	// Create a map to store user IDs and their scores
	userScores := make(map[string]float64)
	var userIDs []string

	// Extract user IDs and scores from Redis result
	for _, z := range redisResult {
		userID := fmt.Sprint(z.Member)
		userIDs = append(userIDs, userID)
		userScores[userID] = z.Score
	}

	// Fetch user names from PostgreSQL for all users in the leaderboard
	query := "SELECT user_id, user_name FROM leaderboard WHERE user_id = ANY($1)"
	rows, err := r.DB.Query(query, userIDs)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user names: %w", err)
	}
	defer rows.Close()

	// Create a map of user IDs to their names
	userNames := make(map[string]string)
	for rows.Next() {
		var userID, userName string
		if err := rows.Scan(&userID, &userName); err != nil {
			return nil, fmt.Errorf("failed to scan user data: %w", err)
		}
		userNames[userID] = userName
	}

	// Build the final leaderboard
	var leaderboard []*model.Leaderboard
	for rank, z := range redisResult {
		userID := fmt.Sprint(z.Member)
		user := &model.Leaderboard{
			UserID:   userID,
			UserName: userNames[userID],
			Score:    int32(z.Score),
			Rank:     int32(rank + 1), // rank is 0-based, add 1 for human-readable ranks
		}
		leaderboard = append(leaderboard, user)
	}

	log.Printf("Leaderboard rows: %d", len(leaderboard))
	return leaderboard, nil
}

// UserByID is the resolver for the userById field.
func (r *queryResolver) UserByID(ctx context.Context, userID string) (*model.Leaderboard, error) {
	var user model.Leaderboard
	err := r.DB.QueryRow("SELECT user_id, user_name, rank, score FROM leaderboard WHERE user_id = $1;", userID).Scan(&user.UserID, &user.UserName, &user.Rank, &user.Score)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
